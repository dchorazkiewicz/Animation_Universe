<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizualizacja Liczb Zespolonych</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: white; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; cursor: crosshair; }
        .panel {
            position: absolute;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }
        .top-panel { top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 0.5rem; z-index: 10; flex-wrap: wrap; justify-content: center; }
        .info-panel { bottom: 20px; left: 20px; min-width: 280px; max-width: 320px; z-index: 10; }
        
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
            background: #334155;
            color: #94a3b8;
            border: 1px solid transparent;
            white-space: nowrap;
        }
        .btn:hover { background: #475569; color: white; }
        .btn.active {
            background: #2563eb;
            color: white;
            border-color: #60a5fa;
            box-shadow: 0 0 10px rgba(37, 99, 235, 0.4);
        }
        
        .math-text { font-family: 'Courier New', monospace; font-weight: 600; }
        .legend-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; }

        /* Style dla sekcji wzorów */
        .formula-section {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease;
            opacity: 0;
            border-top: 1px solid #334155;
            margin-top: 0;
            padding-top: 0;
        }
        .formula-section.visible {
            max-height: 200px; /* Wystarczająco dużo na wzór */
            opacity: 1;
            margin-top: 12px;
            padding-top: 12px;
        }
        .variable { font-style: italic; color: #cbd5e1; }
        .toggle-btn {
            font-size: 0.75rem;
            color: #60a5fa;
            cursor: pointer;
            text-decoration: underline;
            margin-left: auto;
        }
        .toggle-btn:hover { color: #93c5fd; }
    </style>
</head>
<body>

    <!-- Panel Sterowania -->
    <div class="panel top-panel">
        <button class="btn active" onclick="setMode('add')">Dodawanie (+)</button>
        <button class="btn" onclick="setMode('sub')">Odejmowanie (-)</button>
        <button class="btn" onclick="setMode('mul')">Mnożenie (×)</button>
        <button class="btn" onclick="setMode('div')">Dzielenie (÷)</button>
    </div>

    <!-- Panel Informacyjny -->
    <div class="panel info-panel">
        <div class="flex items-center justify-between mb-2">
            <h2 class="text-sm font-bold text-gray-400 uppercase tracking-wide">Wartości</h2>
            <button class="toggle-btn" onclick="toggleFormula()" id="toggleFormulaBtn">Pokaż wzór</button>
        </div>
        
        <div class="space-y-2 text-sm">
            <div class="flex justify-between items-center text-blue-400">
                <span><span class="legend-dot bg-blue-500"></span>z₁ <span class="text-xs text-slate-500">(a+bi)</span></span>
                <span id="val-z1" class="math-text">1.00 + 1.00i</span>
            </div>
            <div class="flex justify-between items-center text-green-400">
                <span><span class="legend-dot bg-green-500"></span>z₂ <span class="text-xs text-slate-500">(c+di)</span></span>
                <span id="val-z2" class="math-text">1.00 - 1.00i</span>
            </div>
            <div class="border-t border-slate-600 my-1"></div>
            <div class="flex justify-between items-center text-red-400 font-bold">
                <span><span class="legend-dot bg-red-500"></span>Wynik (w)</span>
                <span id="val-res" class="math-text">2.00 + 0.00i</span>
            </div>
        </div>

        <!-- Sekcja Wzorów (Chowana) -->
        <div id="formula-section" class="formula-section">
            <div class="text-xs text-gray-400 mb-1 font-semibold">Wzór algebraiczny:</div>
            <div id="algebra-formula" class="text-xs font-mono text-blue-200 leading-relaxed bg-slate-800 p-2 rounded border border-slate-700">
                <!-- Tu wstrzykujemy HTML -->
            </div>
        </div>

        <div id="desc-panel" class="mt-3 text-xs text-slate-400 italic border-t border-slate-700 pt-2">
            Przesuń wektory, aby dodać liczby.
        </div>
    </div>

    <canvas id="complexCanvas"></canvas>

<script>
/**
 * Logika i Renderowanie
 */
const canvas = document.getElementById('complexCanvas');
const ctx = canvas.getContext('2d');

let width, height, cx, cy;
const ZOOM = 50; // Piksele na jednostkę logiczną

// Stan aplikacji
const state = {
    z1: { r: 2, i: 1 },  // Real, Imaginary
    z2: { r: 1, i: 2 },
    mode: 'add',         // add, sub, mul, div
    dragging: null,      // 'z1', 'z2' lub null
    showFormula: false
};

// Dane tekstowe (Opisy i Wzory)
const textData = {
    add: {
        desc: "Interpretacja geometryczna: Reguła równoległoboku. Wynik to suma wektorów.",
        formula: "(<span class='variable'>a</span> + <span class='variable'>c</span>) + (<span class='variable'>b</span> + <span class='variable'>d</span>)i"
    },
    sub: {
        desc: "Interpretacja geometryczna: Różnica wektorów (z₁ - z₂). Przesunięcie wektora od z₂ do z₁.",
        formula: "(<span class='variable'>a</span> - <span class='variable'>c</span>) + (<span class='variable'>b</span> - <span class='variable'>d</span>)i"
    },
    mul: {
        desc: "Geometria: Mnożenie modułów (długości) i dodawanie argumentów (kątów).",
        formula: "(<span class='variable'>ac</span> - <span class='variable'>bd</span>) + (<span class='variable'>ad</span> + <span class='variable'>bc</span>)i"
    },
    div: {
        desc: "Geometria: Dzielenie modułów (długości) i odejmowanie argumentów (kątów).",
        formula: "<div class='text-center border-b border-white/20 mb-1 pb-1'><span class='variable'>ac</span> + <span class='variable'>bd</span> + (<span class='variable'>bc</span> - <span class='variable'>ad</span>)i</div><div class='text-center'><span class='variable'>c</span>² + <span class='variable'>d</span>²</div>"
    }
};

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    cx = width / 2;
    cy = height / 2;
    draw();
}

function setMode(mode) {
    state.mode = mode;
    
    // Aktualizacja opisów
    const data = textData[mode];
    document.getElementById('desc-panel').textContent = data.desc;
    document.getElementById('algebra-formula').innerHTML = data.formula;
    
    // Update UI buttons
    document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
    const buttons = document.querySelectorAll('.btn');
    if(mode === 'add') buttons[0].classList.add('active');
    if(mode === 'sub') buttons[1].classList.add('active');
    if(mode === 'mul') buttons[2].classList.add('active');
    if(mode === 'div') buttons[3].classList.add('active');

    draw();
}

function toggleFormula() {
    state.showFormula = !state.showFormula;
    const el = document.getElementById('formula-section');
    const btn = document.getElementById('toggleFormulaBtn');
    
    if (state.showFormula) {
        el.classList.add('visible');
        btn.textContent = "Ukryj wzór";
    } else {
        el.classList.remove('visible');
        btn.textContent = "Pokaż wzór";
    }
}

// Konwersja współrzędnych
function toScreen(r, i) {
    return { x: cx + r * ZOOM, y: cy - i * ZOOM };
}

function fromScreen(x, y) {
    return { r: (x - cx) / ZOOM, i: (cy - y) / ZOOM };
}

// Matematyka liczb zespolonych
function complexAdd(a, b) { return { r: a.r + b.r, i: a.i + b.i }; }
function complexSub(a, b) { return { r: a.r - b.r, i: a.i - b.i }; }
function complexMul(a, b) { return { r: a.r * b.r - a.i * b.i, i: a.r * b.i + a.i * b.r }; }
function complexDiv(a, b) {
    const denom = b.r * b.r + b.i * b.i;
    if (denom === 0) return { r: 0, i: 0 }; // Zabezpieczenie
    return {
        r: (a.r * b.r + a.i * b.i) / denom,
        i: (a.i * b.r - a.r * b.i) / denom
    };
}
function getMag(z) { return Math.sqrt(z.r*z.r + z.i*z.i); }
function getArg(z) { return Math.atan2(z.i, z.r); }

// Formatowanie tekstu
function fmt(n) {
    const s = n.toFixed(2);
    return n >= 0 ? s : s; // Minus jest już w liczbie
}
function complexStr(z) {
    const sign = z.i >= 0 ? '+' : '-';
    return `${fmt(z.r)} ${sign} ${fmt(Math.abs(z.i))}i`;
}

// Rysowanie
function drawGrid() {
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;

    // Grid lines
    const startX = (cx % ZOOM) - ZOOM;
    const startY = (cy % ZOOM) - ZOOM;

    ctx.beginPath();
    for (let x = startX; x < width; x += ZOOM) {
        ctx.moveTo(x, 0); ctx.lineTo(x, height);
    }
    for (let y = startY; y < height; y += ZOOM) {
        ctx.moveTo(0, y); ctx.lineTo(width, y);
    }
    ctx.stroke();

    // Axes
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, cy); ctx.lineTo(width, cy); // X axis (Re)
    ctx.moveTo(cx, 0); ctx.lineTo(cx, height); // Y axis (Im)
    ctx.stroke();

    // Unit Circle (dla mnożenia/dzielenia ważne)
    ctx.strokeStyle = '#475569';
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(cx, cy, ZOOM, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Axis Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px sans-serif';
    ctx.fillText('Re', width - 20, cy + 20);
    ctx.fillText('Im', cx + 10, 20);
    ctx.fillText('1', cx + ZOOM + 2, cy + 15);
    ctx.fillText('i', cx + 5, cy - ZOOM + 5);
}

function drawArrow(from, to, color, label) {
    const headlen = 10;
    const angle = Math.atan2(to.y - from.y, to.x - from.x);

    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 3;

    // Line
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // Head
    ctx.beginPath();
    ctx.moveTo(to.x, to.y);
    ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(to.x, to.y);
    ctx.fill();

    // Label
    if (label) {
        ctx.font = 'bold 14px sans-serif';
        ctx.fillStyle = color;
        ctx.fillText(label, to.x + 10, to.y);
    }
}

function drawPoint(pos, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawDashedLine(p1, p2, color) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    ctx.restore();
}

function drawAngleArc(radius, endAngle, color, label) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, radius, 0, -endAngle, true); // Canvas Y is inverted relative to math
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.5;
    ctx.stroke();
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
}

function draw() {
    ctx.clearRect(0, 0, width, height);
    drawGrid();

    const origin = { x: cx, y: cy };
    const p1 = toScreen(state.z1.r, state.z1.i);
    const p2 = toScreen(state.z2.r, state.z2.i);

    // Oblicz wynik
    let res;
    if (state.mode === 'add') res = complexAdd(state.z1, state.z2);
    else if (state.mode === 'sub') res = complexSub(state.z1, state.z2);
    else if (state.mode === 'mul') res = complexMul(state.z1, state.z2);
    else if (state.mode === 'div') res = complexDiv(state.z1, state.z2);
    
    const pRes = toScreen(res.r, res.i);

    // Helpers geometryczne w zależności od trybu
    if (state.mode === 'add') {
        // Równoległobok
        drawDashedLine(p1, pRes, '#4ade80'); // Od z1 do wyniku (równoległy do z2)
        drawDashedLine(p2, pRes, '#60a5fa'); // Od z2 do wyniku (równoległy do z1)
    } else if (state.mode === 'sub') {
        // Wektor różnicy między końcówkami
        drawDashedLine(p2, p1, '#f87171'); // Od z2 do z1
        // Przesunięcie wektora różnicy do początku układu to wynik
    } else if (state.mode === 'mul' || state.mode === 'div') {
        // Łuki kątów
        // Kąty w matematyce rosną przeciwnie do zegara (CCW), w Canvas Y rośnie w dół.
        // Używamy Math.atan2(y, x), pamiętając, że nasze 'y' to -imag.
        // Ale toScreen już odwraca Y. Więc operujmy na wartościach logicznych.
        
        const r1 = Math.sqrt(state.z1.r**2 + state.z1.i**2) * ZOOM;
        const r2 = Math.sqrt(state.z2.r**2 + state.z2.i**2) * ZOOM;
        
        // Wizualizacja kątów (tylko małe łuczki przy środku)
        // Dla czystości rysujemy je tylko jeśli nie są zerowe
        drawAngleArc(30, getArg(state.z1), '#60a5fa');
        drawAngleArc(40, getArg(state.z2), '#4ade80');
        if(getMag(res) > 0.1) drawAngleArc(50, getArg(res), '#f87171');
    }

    // Rysowanie głównych wektorów
    // z1
    drawArrow(origin, p1, '#3b82f6', 'z₁');
    drawPoint(p1, '#3b82f6');

    // z2
    drawArrow(origin, p2, '#22c55e', 'z₂');
    drawPoint(p2, '#22c55e');

    // Wynik
    drawArrow(origin, pRes, '#ef4444', 'w');
    
    // Update panelu
    document.getElementById('val-z1').innerText = complexStr(state.z1);
    document.getElementById('val-z2').innerText = complexStr(state.z2);
    document.getElementById('val-res').innerText = complexStr(res);
}

// Obsługa Myszki / Dotyku
function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.clientX || (evt.touches ? evt.touches[0].clientX : 0);
    const clientY = evt.clientY || (evt.touches ? evt.touches[0].clientY : 0);
    return { x: clientX - rect.left, y: clientY - rect.top };
}

function handleStart(evt) {
    const pos = getMousePos(evt);
    const p1 = toScreen(state.z1.r, state.z1.i);
    const p2 = toScreen(state.z2.r, state.z2.i);
    
    const d1 = Math.hypot(pos.x - p1.x, pos.y - p1.y);
    const d2 = Math.hypot(pos.x - p2.x, pos.y - p2.y);
    
    const HIT_RADIUS = 20;

    // Prosty priorytet: bliższy punkt
    if (d1 < HIT_RADIUS && d1 < d2) {
        state.dragging = 'z1';
    } else if (d2 < HIT_RADIUS) {
        state.dragging = 'z2';
    }
}

function handleMove(evt) {
    if (!state.dragging) return;
    evt.preventDefault();
    const pos = getMousePos(evt);
    const logicPos = fromScreen(pos.x, pos.y);
    
    // Snap to integers (opcjonalnie, ale ułatwia demonstrację)
    // logicPos.r = Math.round(logicPos.r * 2) / 2;
    // logicPos.i = Math.round(logicPos.i * 2) / 2;

    if (state.dragging === 'z1') {
        state.z1 = logicPos;
    } else {
        state.z2 = logicPos;
    }
    draw();
}

function handleEnd() {
    state.dragging = null;
}

// Event Listeners
window.addEventListener('resize', resize);
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);

canvas.addEventListener('touchstart', handleStart, {passive: false});
canvas.addEventListener('touchmove', handleMove, {passive: false});
canvas.addEventListener('touchend', handleEnd);

// Start
setMode('add'); // Inicjalizuje tekst
resize();

</script>
</body>
</html>
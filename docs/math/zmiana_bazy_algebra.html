<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Porównanie Dwóch Baz Wektorowych (Dark Mode)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b', 
                            900: '#0f172a',
                            950: '#020617',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        canvas { 
            background-color: #1e293b; 
            cursor: crosshair; 
            touch-action: none; 
            border-radius: 8px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            border: 1px solid #334155;
        }
        .math-font { font-family: 'JetBrains Mono', monospace; }
        
        /* Jaśniejsze kolory dla Dark Mode */
        .color-red { color: #f87171; } /* Red-400 */
        .color-blue { color: #60a5fa; } /* Blue-400 */
        .color-green { color: #4ade80; } /* Green-400 */
        
        .matrix-bracket {
            border-left: 2px solid #64748b;
            border-right: 2px solid #64748b;
            border-radius: 4px;
            padding: 0 4px;
            display: inline-block;
        }
        
        .panel-card {
            background-color: #1e293b;
            border: 1px solid #334155;
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center min-h-screen">

    <div class="w-full max-w-7xl">
        <header class="mb-6 text-center">
            <h1 class="text-2xl font-bold text-slate-100">Zmiana Bazy w Przestrzeni Wektorowej</h1>
            <p class="text-slate-400 text-sm mt-1">
                Wektor <span class="color-green font-bold">w</span> jest stały. Zobacz jak zmieniają się jego współrzędne w zależności od wybranej bazy.
            </p>
        </header>

        <!-- Główny Grid: Panele po lewej, Canvas po prawej -->
        <div class="flex flex-col lg:flex-row gap-6 items-start justify-center">
            
            <!-- LEWA KOLUMNA: PANELE BAZ I WYNIKI -->
            <div class="flex flex-col gap-4 w-full lg:w-[380px] shrink-0 order-2 lg:order-1">
                
                <!-- KONTROLA WIDOCZNOŚCI -->
                <div class="panel-card p-4 rounded-xl shadow-lg flex flex-col gap-3">
                    <h3 class="text-xs font-bold text-slate-500 uppercase tracking-wider">Widoczność Baz</h3>
                    <div class="flex gap-4">
                        <label class="flex items-center gap-2 cursor-pointer hover:bg-slate-800 p-2 rounded transition border border-transparent hover:border-slate-700">
                            <input type="checkbox" id="showRed" checked class="accent-red-500 w-4 h-4">
                            <span class="color-red font-bold text-sm">Baza U (Czerwona)</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer hover:bg-slate-800 p-2 rounded transition border border-transparent hover:border-slate-700">
                            <input type="checkbox" id="showBlue" checked class="accent-blue-500 w-4 h-4">
                            <span class="color-blue font-bold text-sm">Baza V (Niebieska)</span>
                        </label>
                    </div>
                </div>

                <!-- BAZA U (CZERWONA) -->
                <div class="panel-card rounded-xl shadow-lg border-l-4 border-l-red-400 p-5">
                    <h3 class="text-sm font-bold color-red mb-4 uppercase tracking-wide border-b border-slate-700 pb-2">Baza U (Czerwona)</h3>
                    
                    <div class="math-font text-xs text-slate-400 mb-4 grid grid-cols-2 gap-2">
                        <div>u₁ = [<span id="ra_x"></span>, <span id="ra_y"></span>]</div>
                        <div>u₂ = [<span id="rb_x"></span>, <span id="rb_y"></span>]</div>
                    </div>
                    
                    <div class="bg-slate-900/50 p-3 rounded border border-red-900/30 mb-4">
                        <div class="text-xs text-slate-500 mb-1">Współczynniki (najedź na rzut):</div>
                        <div class="math-font text-lg font-bold color-red flex justify-between">
                            <span>c₁ = <span id="res_ra">0.0</span></span>
                            <span>c₂ = <span id="res_rb">0.0</span></span>
                        </div>
                        <div class="text-[10px] text-slate-500 mt-1 italic text-right">w = c₁·u₁ + c₂·u₂</div>
                    </div>

                    <div class="text-xs text-center math-font text-slate-300">
                        <div class="inline-flex items-center gap-1">
                            <div class="matrix-bracket grid grid-cols-2 text-right gap-x-3 color-red">
                                <span id="m_ra_x"></span><span id="m_rb_x"></span>
                                <span id="m_ra_y"></span><span id="m_rb_y"></span>
                            </div>
                            <span>·</span>
                            <div class="matrix-bracket flex flex-col color-red"><span>c₁</span><span>c₂</span></div>
                            <span>=</span>
                            <div class="matrix-bracket flex flex-col color-green"><span id="mw_ra"></span><span id="mw_rb"></span></div>
                        </div>
                    </div>
                </div>

                <!-- BAZA V (NIEBIESKA) -->
                <div class="panel-card rounded-xl shadow-lg border-l-4 border-l-blue-400 p-5">
                    <h3 class="text-sm font-bold color-blue mb-4 uppercase tracking-wide border-b border-slate-700 pb-2">Baza V (Niebieska)</h3>
                    
                    <div class="math-font text-xs text-slate-400 mb-4 grid grid-cols-2 gap-2">
                        <div>v₁ = [<span id="ba_x"></span>, <span id="ba_y"></span>]</div>
                        <div>v₂ = [<span id="bb_x"></span>, <span id="bb_y"></span>]</div>
                    </div>

                    <div class="bg-slate-900/50 p-3 rounded border border-blue-900/30 mb-4">
                        <div class="text-xs text-slate-500 mb-1">Współczynniki (najedź na rzut):</div>
                        <div class="math-font text-lg font-bold color-blue flex justify-between">
                            <span>d₁ = <span id="res_ba">0.0</span></span>
                            <span>d₂ = <span id="res_bb">0.0</span></span>
                        </div>
                        <div class="text-[10px] text-slate-500 mt-1 italic text-right">w = d₁·v₁ + d₂·v₂</div>
                    </div>

                     <div class="text-xs text-center math-font text-slate-300">
                        <div class="inline-flex items-center gap-1">
                            <div class="matrix-bracket grid grid-cols-2 text-right gap-x-3 color-blue">
                                <span id="m_ba_x"></span><span id="m_bb_x"></span>
                                <span id="m_ba_y"></span><span id="m_bb_y"></span>
                            </div>
                            <span>·</span>
                            <div class="matrix-bracket flex flex-col color-blue"><span>d₁</span><span>d₂</span></div>
                            <span>=</span>
                            <div class="matrix-bracket flex flex-col color-green"><span id="mw_ba"></span><span id="mw_bb"></span></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- PRAWA KOLUMNA: CANVAS -->
            <div class="flex flex-col gap-2 order-1 lg:order-2">
                <div class="relative">
                    <canvas id="vectorCanvas" width="700" height="600"></canvas>
                    
                    <!-- Legenda Overlay -->
                    <div class="absolute bottom-4 left-4 bg-slate-900/90 p-3 rounded border border-slate-700 text-[10px] text-slate-400 pointer-events-none shadow-xl">
                        <div class="flex items-center gap-2 mb-1"><div class="w-3 h-0.5 bg-slate-500"></div> Osie standardowe (x,y)</div>
                        <div class="flex items-center gap-2 mb-1"><div class="w-3 h-0.5 bg-red-400 opacity-50 border-t border-dashed border-red-400"></div> Osie bazy U (u₁, u₂)</div>
                        <div class="flex items-center gap-2 mb-1"><div class="w-3 h-0.5 bg-blue-400 opacity-50 border-t border-dashed border-blue-400"></div> Osie bazy V (v₁, v₂)</div>
                        <div class="mt-1 text-slate-500 italic">Najedź myszką na punkty rzutu, by zobaczyć wartości.</div>
                    </div>
                </div>
            </div>

        </div>
    </div>

<script>
    const canvas = document.getElementById('vectorCanvas');
    const ctx = canvas.getContext('2d');
    const gridScale = 40; // Pixele na jednostkę standardową
    
    const showRedCheck = document.getElementById('showRed');
    const showBlueCheck = document.getElementById('showBlue');

    let origin = { x: canvas.width / 2, y: canvas.height / 2 };
    let mousePos = { x: 0, y: 0 };

    // Stan aplikacji - Zaktualizowane etykiety
    const state = {
        ra: { x: origin.x + 3 * gridScale, y: origin.y - 1 * gridScale, color: '#f87171', label: 'u₁' },
        rb: { x: origin.x + 1 * gridScale, y: origin.y - 3 * gridScale, color: '#f87171', label: 'u₂' },
        
        ba: { x: origin.x - 2 * gridScale, y: origin.y - 1 * gridScale, color: '#60a5fa', label: 'v₁' },
        bb: { x: origin.x - 3 * gridScale, y: origin.y + 2 * gridScale, color: '#60a5fa', label: 'v₂' },
        
        w:  { x: origin.x + 2 * gridScale, y: origin.y - 4 * gridScale, color: '#4ade80', label: 'w' }
    };

    let dragging = null;

    function toCart(p) { return { x: (p.x - origin.x) / gridScale, y: -(p.y - origin.y) / gridScale }; }
    function det(v1, v2) { return v1.x * v2.y - v1.y * v2.x; }
    function solve(v1, v2, target) {
        const d = det(v1, v2);
        if (Math.abs(d) < 1e-6) return null; 
        return { c1: det(target, v2) / d, c2: det(v1, target) / d };
    }

    // --- RYSOWANIE ---

    function drawGridAndAxes() {
        // Tło siatki
        ctx.save();
        ctx.strokeStyle = '#334155'; // Slate-700
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.3;
        
        // Siatka
        for (let i = 0; i < canvas.width; i+=gridScale) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }
        for (let i = 0; i < canvas.height; i+=gridScale) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); ctx.stroke(); }
        
        // Osie Główne (Standardowe)
        ctx.strokeStyle = '#94a3b8'; // Slate-400
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.8;
        
        // X Axis
        ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
        // Y Axis
        ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height); ctx.stroke();

        // Podziałka na osiach standardowych
        ctx.fillStyle = '#64748b';
        ctx.font = "10px Inter";
        ctx.textAlign = "center";
        
        for (let i = -10; i <= 10; i++) {
            if (i === 0) continue;
            // X ticks
            let x = origin.x + i * gridScale;
            if (x > 0 && x < canvas.width) {
                ctx.beginPath(); ctx.moveTo(x, origin.y - 3); ctx.lineTo(x, origin.y + 3); ctx.stroke();
            }
            // Y ticks
            let y = origin.y - i * gridScale;
            if (y > 0 && y < canvas.height) {
                ctx.beginPath(); ctx.moveTo(origin.x - 3, y); ctx.lineTo(origin.x + 3, y); ctx.stroke();
            }
        }

        ctx.restore();
    }

    // Rysuje nieskończoną linię wyznaczaną przez wektor bazy z podziałką (tickami)
    function drawBasisAxis(p, color) {
        const dx = p.x - origin.x;
        const dy = p.y - origin.y;
        
        if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;

        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.globalAlpha = 0.4;

        // Oś
        const range = 20; // Ile jednostek wektora w każdą stronę
        ctx.beginPath();
        ctx.moveTo(origin.x - dx * range, origin.y - dy * range);
        ctx.lineTo(origin.x + dx * range, origin.y + dy * range);
        ctx.stroke();

        // Ticki (podziałka co 1 długość wektora)
        ctx.setLineDash([]);
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = 1.5;

        // Normalizacja do prostopadłego wektora dla rysowania kresek
        const len = Math.sqrt(dx*dx + dy*dy);
        const perpX = (-dy / len) * 4; // długość kreski podziałki
        const perpY = (dx / len) * 4;

        for (let i = -range; i <= range; i++) {
            if (i === 0) continue;
            const px = origin.x + i * dx;
            const py = origin.y + i * dy;

            // Sprawdzamy czy punkt jest w canvasie
            if (px > 0 && px < canvas.width && py > 0 && py < canvas.height) {
                ctx.beginPath();
                ctx.moveTo(px - perpX, py - perpY);
                ctx.lineTo(px + perpX, py + perpY);
                ctx.stroke();
            }
        }
        ctx.restore();
    }

    function drawArrow(from, to, color, label, isDash=false, width=2) {
        const head = 10;
        const angle = Math.atan2(to.y - from.y, to.x - from.x);
        
        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = width;
        if(isDash) ctx.setLineDash([5, 5]);

        ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();

        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(to.x - head * Math.cos(angle - Math.PI/6), to.y - head * Math.sin(angle - Math.PI/6));
        ctx.lineTo(to.x - head * Math.cos(angle + Math.PI/6), to.y - head * Math.sin(angle + Math.PI / 6));
        ctx.fill();

        if (label && !isDash) {
            ctx.font = "bold 14px Inter";
            ctx.shadowColor = "rgba(0,0,0,0.8)";
            ctx.shadowBlur = 4;
            ctx.fillText(label, to.x + 12, to.y - 12);
            
            ctx.beginPath(); ctx.arc(to.x, to.y, 5, 0, Math.PI*2); 
            ctx.fillStyle='#f1f5f9'; ctx.fill(); ctx.stroke();
        }
        ctx.restore();
    }

    function drawTooltip(pos, text, color) {
        ctx.save();
        ctx.font = "bold 12px JetBrains Mono";
        const w = ctx.measureText(text).width + 12;
        const h = 24;
        
        // Tło tooltipa
        ctx.fillStyle = '#0f172a';
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(pos.x + 10, pos.y - 30, w, h, 4);
        ctx.fill();
        ctx.stroke();

        // Tekst
        ctx.fillStyle = color;
        ctx.fillText(text, pos.x + 16, pos.y - 14);
        
        // Kropka wskazująca
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 4, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.fill(); 
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        
        ctx.restore();
    }

    function drawProjection(v1, v2, target, sol, color) {
        if (!sol) return;

        // Oś (cała prosta) + Podziałka
        drawBasisAxis(v1, color);
        drawBasisAxis(v2, color);

        // Punkty rzutowania fizycznie na ekranie
        const p1 = { x: origin.x + (v1.x - origin.x) * sol.c1, y: origin.y + (v1.y - origin.y) * sol.c1 };
        const p2 = { x: origin.x + (v2.x - origin.x) * sol.c2, y: origin.y + (v2.y - origin.y) * sol.c2 };

        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([2, 4]); 
        ctx.globalAlpha = 0.8;

        // Linie rzutu
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(target.x, target.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p2.x, p2.y); ctx.lineTo(target.x, target.y); ctx.stroke();
        ctx.restore();

        // Obsługa Tooltipów po najechaniu na punkt rzutu
        const mouseDist1 = Math.hypot(p1.x - mousePos.x, p1.y - mousePos.y);
        const mouseDist2 = Math.hypot(p2.x - mousePos.x, p2.y - mousePos.y);
        const hoverThreshold = 15;

        if (mouseDist1 < hoverThreshold) {
            drawTooltip(p1, sol.c1.toFixed(2), color);
        } else {
            // Mała kropka jeśli nie najechane
            ctx.beginPath(); ctx.arc(p1.x, p1.y, 3, 0, Math.PI*2); ctx.fillStyle=color; ctx.fill();
        }

        if (mouseDist2 < hoverThreshold) {
            drawTooltip(p2, sol.c2.toFixed(2), color);
        } else {
            ctx.beginPath(); ctx.arc(p2.x, p2.y, 3, 0, Math.PI*2); ctx.fillStyle=color; ctx.fill();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawGridAndAxes();

        const c_w = toCart(state.w);
        
        // --- BAZA A (RED) ---
        if (showRedCheck.checked) {
            const c_ra = toCart(state.ra);
            const c_rb = toCart(state.rb);
            const solA = solve(c_ra, c_rb, c_w);
            drawProjection(state.ra, state.rb, state.w, solA, state.ra.color);
            drawArrow(origin, state.ra, state.ra.color, state.ra.label);
            drawArrow(origin, state.rb, state.rb.color, state.rb.label);
            updatePanel('ra', 'rb', c_ra, c_rb, solA, c_w);
        } else { updatePanelEmpty('ra', 'rb'); }

        // --- BAZA B (BLUE) ---
        if (showBlueCheck.checked) {
            const c_ba = toCart(state.ba);
            const c_bb = toCart(state.bb);
            const solB = solve(c_ba, c_bb, c_w);
            drawProjection(state.ba, state.bb, state.w, solB, state.ba.color);
            drawArrow(origin, state.ba, state.ba.color, state.ba.label);
            drawArrow(origin, state.bb, state.bb.color, state.bb.label);
            updatePanel('ba', 'bb', c_ba, c_bb, solB, c_w);
        } else { updatePanelEmpty('ba', 'bb'); }

        // Wektor W
        drawArrow(origin, state.w, state.w.color, state.w.label, false, 3);
        
        // Punkt (0,0)
        ctx.beginPath(); ctx.arc(origin.x, origin.y, 4, 0, Math.PI*2); ctx.fillStyle='#94a3b8'; ctx.fill();
    }

    function updatePanel(uName, vName, uCart, vCart, sol, wCart) {
        const fmt = n => n.toFixed(1);
        const fmt2 = n => n.toFixed(2);
        document.getElementById(`${uName}_x`).innerText = fmt(uCart.x);
        document.getElementById(`${uName}_y`).innerText = fmt(uCart.y);
        document.getElementById(`${vName}_x`).innerText = fmt(vCart.x);
        document.getElementById(`${vName}_y`).innerText = fmt(vCart.y);
        if (sol) {
            document.getElementById(`res_${uName}`).innerText = fmt2(sol.c1);
            document.getElementById(`res_${vName}`).innerText = fmt2(sol.c2);
        } else {
            document.getElementById(`res_${uName}`).innerText = "Err";
            document.getElementById(`res_${vName}`).innerText = "Err";
        }
        document.getElementById(`m_${uName}_x`).innerText = fmt(uCart.x);
        document.getElementById(`m_${uName}_y`).innerText = fmt(uCart.y);
        document.getElementById(`m_${vName}_x`).innerText = fmt(vCart.x);
        document.getElementById(`m_${vName}_y`).innerText = fmt(vCart.y);
        document.getElementById(`mw_${uName}`).innerText = fmt(wCart.x);
        document.getElementById(`mw_${vName}`).innerText = fmt(wCart.y);
    }
    function updatePanelEmpty(u,v) {} 

    function dist(p1, p2) { return Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2); }
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: (e.touches ? e.touches[0].clientX : e.clientX) - rect.left, 
                 y: (e.touches ? e.touches[0].clientY : e.clientY) - rect.top };
    }

    canvas.addEventListener('mousedown', e => handleStart(getPos(e)));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(getPos(e)); }, {passive:false});
    
    function handleStart(pos) {
        const keys = Object.keys(state);
        let closest = null, minD = 30;
        for (let key of keys) {
            if (key.startsWith('r') && !showRedCheck.checked) continue;
            if (key.startsWith('b') && !showBlueCheck.checked) continue;
            const d = dist(pos, state[key]);
            if (d < minD) { minD = d; closest = key; }
        }
        if(closest) dragging = closest;
    }

    window.addEventListener('mousemove', e => {
        mousePos = getPos(e); // Aktualizacja pozycji dla tooltipów
        if (dragging) {
            handleMove(mousePos);
        } else {
            draw(); // Przerysowanie dla tooltipów
        }
    });
    
    window.addEventListener('touchmove', e => { 
        mousePos = getPos(e);
        if(dragging) { e.preventDefault(); handleMove(mousePos); }
    }, {passive:false});

    function handleMove(pos) {
        state[dragging].x = pos.x;
        state[dragging].y = pos.y;
        draw();
    }
    
    window.addEventListener('mouseup', () => dragging = null);
    window.addEventListener('touchend', () => dragging = null);
    showRedCheck.addEventListener('change', draw);
    showBlueCheck.addEventListener('change', draw);

    // Initial draw
    draw();
</script>
</body>
</html>
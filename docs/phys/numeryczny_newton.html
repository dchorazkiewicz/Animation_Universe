<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Numeryczny ODE - Live Comparison</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { touch-action: none; }
        /* Custom scrollbar for sidebar */
        aside::-webkit-scrollbar { width: 6px; }
        aside::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 3px; }
        aside::-webkit-scrollbar-track { background-color: #1f2937; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-gray-800 p-3 border-b border-gray-700 flex justify-between items-center shrink-0 h-14">
        <div class="flex items-center gap-4">
            <h1 class="text-lg font-bold text-blue-400">Symulator ODE: Euler vs RK4</h1>
            <div class="text-xs text-gray-500 hidden md:block">Porównanie w czasie rzeczywistym</div>
        </div>
        <div class="flex space-x-2">
            <button onclick="window.app.setScenario('projectile')" id="btn-projectile" class="px-3 py-1.5 rounded bg-blue-600 hover:bg-blue-500 transition text-xs font-bold uppercase tracking-wider">Rzut Ukośny</button>
            <button onclick="window.app.setScenario('orbit')" id="btn-orbit" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600 transition text-xs font-bold uppercase tracking-wider">Orbita</button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden flex-col md:flex-row">
        
        <!-- Sidebar Controls -->
        <aside class="w-full md:w-72 bg-gray-800 p-4 border-r border-gray-700 overflow-y-auto shrink-0 flex flex-col gap-5 z-10">
            
            <!-- Playback Controls -->
            <div class="grid grid-cols-2 gap-2">
                <button onclick="window.app.togglePlay()" id="btn-play" class="col-span-1 py-2 bg-emerald-600 hover:bg-emerald-500 text-white rounded font-bold shadow transition flex justify-center items-center gap-1">
                    <span id="icon-play">▶</span> Start
                </button>
                <button onclick="window.app.reset()" class="col-span-1 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded font-bold shadow transition">
                    Reset
                </button>
            </div>

            <!-- Parameters Section -->
            <div class="space-y-4">
                <h2 class="text-xs font-bold text-gray-400 uppercase tracking-widest border-b border-gray-600 pb-1">Parametry Fizyczne</h2>
                
                <div id="controls-projectile">
                    <label class="block text-xs text-gray-400 mb-1">Prędkość ($v_0$)</label>
                    <input type="range" id="proj-v0" min="10" max="150" value="60" class="w-full h-1.5 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <div class="text-right text-xs text-blue-300 font-mono" id="val-proj-v0">60 m/s</div>

                    <label class="block text-xs text-gray-400 mt-2 mb-1">Kąt rzutu ($\alpha$)</label>
                    <input type="range" id="proj-angle" min="10" max="85" value="45" class="w-full h-1.5 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <div class="text-right text-xs text-blue-300 font-mono" id="val-proj-angle">45°</div>
                </div>

                <div id="controls-orbit" class="hidden">
                    <label class="block text-xs text-gray-400 mb-1">Prędkość startowa ($v_y$)</label>
                    <input type="range" id="orb-v" min="0.5" max="1.8" step="0.1" value="1.3" class="w-full h-1.5 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <div class="text-right text-xs text-blue-300 font-mono" id="val-orb-v">1.3</div>
                </div>
            </div>

            <!-- Simulation Parameters -->
            <div class="space-y-4">
                <h2 class="text-xs font-bold text-gray-400 uppercase tracking-widest border-b border-gray-600 pb-1">Parametry Numeryczne</h2>
                
                <div>
                    <label class="block text-xs text-gray-400 mb-1">Krok całkowania ($h$)</label>
                    <input type="range" id="time-step" min="0.01" max="0.5" step="0.01" value="0.1" class="w-full h-1.5 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-yellow-500">
                    <div class="flex justify-between text-xs font-mono mt-1">
                        <span class="text-yellow-400" id="val-time-step">h = 0.10s</span>
                    </div>
                </div>

                <div>
                    <label class="block text-xs text-gray-400 mb-1">Prędkość symulacji (kroki/klatkę)</label>
                    <input type="range" id="sim-speed" min="1" max="20" step="1" value="1" class="w-full h-1.5 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-purple-500">
                    <div class="text-right text-xs text-purple-300 font-mono" id="val-sim-speed">1x</div>
                </div>
            </div>

            <!-- Stats/Legend -->
            <div class="bg-black/30 p-3 rounded border border-gray-700 text-xs space-y-2 font-mono mt-auto">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-red-500"></div>
                    <span>Metoda Eulera (1. rząd)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-green-500"></div>
                    <span>Runge-Kutta 4 (4. rząd)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-white/30 border border-white"></div>
                    <span>Rozwiązanie dokładne</span>
                </div>
            </div>

        </aside>

        <!-- Visualization Area -->
        <main class="flex-1 flex flex-col relative bg-black overflow-hidden">
            
            <!-- Physics Canvas -->
            <div class="flex-grow relative border-b border-gray-800">
                <canvas id="simCanvas" class="absolute top-0 left-0 w-full h-full block cursor-crosshair"></canvas>
                <div class="absolute top-2 right-2 text-xs font-mono text-gray-500 pointer-events-none">
                    Czas symulacji: <span id="sim-time" class="text-white">0.00</span>s
                </div>
                <!-- Scale Info -->
                <div class="absolute bottom-2 right-2 text-[10px] text-gray-600 font-mono pointer-events-none" id="scale-info">
                    Skala: Auto
                </div>
            </div>

            <!-- Error Chart Canvas -->
            <div class="h-40 shrink-0 bg-gray-900 relative border-t border-gray-700">
                <div class="absolute top-1 left-2 text-[10px] text-gray-400 font-bold uppercase">Błąd położenia ($\Delta r$) w czasie</div>
                <canvas id="chartCanvas" class="w-full h-full block"></canvas>
            </div>
            
        </main>

    </div>

    <script>
    { // Block scope start
        
        // --- Physics Constants ---
        const G_CONST = 40; // Adjusted G for visual scaling in orbit
        const M_BODY = 100; // Mass of central body
        const G_EARTH = 9.81;

        // --- Analytical & Derivatives ---

        // Projectile Derivatives (for numerical methods)
        const projectileDerivs = (state) => {
            const [x, y, vx, vy] = state;
            return [vx, vy, 0, -G_EARTH];
        };

        // Projectile Analytic Solution (The "Truth")
        const projectileAnalytic = (t, v0, angleRad) => {
            const vx0 = v0 * Math.cos(angleRad);
            const vy0 = v0 * Math.sin(angleRad);
            return {
                x: vx0 * t,
                y: vy0 * t - 0.5 * G_EARTH * t * t
            };
        };

        // Orbit Derivatives
        const orbitDerivs = (state) => {
            const [x, y, vx, vy] = state;
            const r2 = x*x + y*y;
            const r = Math.sqrt(r2);
            const force = G_CONST * M_BODY / (r2 * r); // GM/r^3
            return [vx, vy, -x * force, -y * force];
        };

        // Orbit "Truth" (High Precision Integrator)
        function highResStep(state, dt) {
            let tempState = [...state];
            const subDt = dt / 10; 
            for(let i=0; i<10; i++) {
                tempState = rk4Step(tempState, orbitDerivs, subDt);
            }
            return tempState;
        }

        // --- Solvers ---

        function eulerStep(state, derivFunc, dt) {
            const d = derivFunc(state);
            return state.map((v, i) => v + d[i] * dt);
        }

        function rk4Step(state, derivFunc, dt) {
            const k1 = derivFunc(state);
            const s1 = state.map((v, i) => v + k1[i] * dt * 0.5);
            
            const k2 = derivFunc(s1);
            const s2 = state.map((v, i) => v + k2[i] * dt * 0.5);
            
            const k3 = derivFunc(s2);
            const s3 = state.map((v, i) => v + k3[i] * dt);
            
            const k4 = derivFunc(s3);
            
            return state.map((v, i) => v + (dt/6) * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
        }

        // --- Application Class ---

        class App {
            constructor() {
                this.simCanvas = document.getElementById('simCanvas');
                this.chartCanvas = document.getElementById('chartCanvas');
                this.ctxSim = this.simCanvas.getContext('2d');
                this.ctxChart = this.chartCanvas.getContext('2d');

                this.scenario = 'projectile';
                this.isRunning = false;
                this.t = 0;
                
                // Physics State [x, y, vx, vy]
                this.stateEuler = [];
                this.stateRK4 = [];
                this.stateTrue = []; 
                this.initialState = [];

                // Viewport tracking (Auto-scale)
                // Projectile: track max X and max Y
                // Orbit: track max radius from center
                this.viewBounds = { maxX: 1, maxY: 1, maxR: 1 };

                // History for visualization
                this.pathEuler = [];
                this.pathRK4 = [];
                this.pathTrue = [];
                
                // Error History
                this.errors = [];

                this.ui = {
                    btnPlay: document.getElementById('btn-play'),
                    iconPlay: document.getElementById('icon-play'),
                    timeDisplay: document.getElementById('sim-time'),
                    scaleInfo: document.getElementById('scale-info'),
                    // Inputs
                    v0: document.getElementById('proj-v0'),
                    angle: document.getElementById('proj-angle'),
                    orbV: document.getElementById('orb-v'),
                    h: document.getElementById('time-step'),
                    speed: document.getElementById('sim-speed'),
                    // Labels
                    lblV0: document.getElementById('val-proj-v0'),
                    lblAngle: document.getElementById('val-proj-angle'),
                    lblOrbV: document.getElementById('val-orb-v'),
                    lblH: document.getElementById('val-time-step'),
                    lblSpeed: document.getElementById('val-sim-speed')
                };

                this.bindEvents();
                this.resize();
                this.reset();
                
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            bindEvents() {
                window.addEventListener('resize', () => this.resize());
                
                const updateParams = () => {
                    this.updateLabels();
                    if(!this.isRunning) this.reset(); 
                };

                this.ui.v0.addEventListener('input', updateParams);
                this.ui.angle.addEventListener('input', updateParams);
                this.ui.orbV.addEventListener('input', updateParams);
                
                this.ui.h.addEventListener('input', () => { 
                    this.updateLabels(); 
                    this.reset(); 
                });
                
                this.ui.speed.addEventListener('input', () => this.updateLabels());
            }

            setScenario(name) {
                this.scenario = name;
                
                // Toggle UI state...
                const isProj = name === 'projectile';
                document.getElementById('btn-projectile').className = isProj 
                    ? "px-3 py-1.5 rounded bg-blue-600 hover:bg-blue-500 transition text-xs font-bold uppercase tracking-wider"
                    : "px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600 transition text-xs font-bold uppercase tracking-wider";
                document.getElementById('btn-orbit').className = !isProj 
                    ? "px-3 py-1.5 rounded bg-blue-600 hover:bg-blue-500 transition text-xs font-bold uppercase tracking-wider"
                    : "px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600 transition text-xs font-bold uppercase tracking-wider";

                if(isProj) {
                    document.getElementById('controls-projectile').classList.remove('hidden');
                    document.getElementById('controls-orbit').classList.add('hidden');
                } else {
                    document.getElementById('controls-projectile').classList.add('hidden');
                    document.getElementById('controls-orbit').classList.remove('hidden');
                }
                
                this.reset();
            }

            updateLabels() {
                this.ui.lblV0.textContent = `${this.ui.v0.value} m/s`;
                this.ui.lblAngle.textContent = `${this.ui.angle.value}°`;
                this.ui.lblOrbV.textContent = parseFloat(this.ui.orbV.value).toFixed(2);
                this.ui.lblH.textContent = `h = ${parseFloat(this.ui.h.value).toFixed(2)}s`;
                this.ui.lblSpeed.textContent = `${this.ui.speed.value}x`;
            }

            togglePlay() {
                this.isRunning = !this.isRunning;
                this.ui.iconPlay.textContent = this.isRunning ? "⏸" : "▶";
                this.ui.btnPlay.className = this.isRunning 
                    ? "col-span-1 py-2 bg-yellow-600 hover:bg-yellow-500 text-white rounded font-bold shadow transition flex justify-center items-center gap-1"
                    : "col-span-1 py-2 bg-emerald-600 hover:bg-emerald-500 text-white rounded font-bold shadow transition flex justify-center items-center gap-1";
                this.ui.btnPlay.childNodes[2].textContent = this.isRunning ? " Pauza" : " Start";
            }

            reset() {
                this.isRunning = false;
                this.t = 0;
                this.pathEuler = [];
                this.pathRK4 = [];
                this.pathTrue = [];
                this.errors = [];
                this.ui.timeDisplay.textContent = "0.00";
                
                // Reset View Bounds to default minimums
                if (this.scenario === 'projectile') {
                    // Min view: 100m wide, 50m high
                    this.viewBounds = { maxX: 100, maxY: 50, maxR: 0 };
                } else {
                    // Min view: 250 units radius
                    this.viewBounds = { maxX: 0, maxY: 0, maxR: 250 };
                }
                
                this.ui.iconPlay.textContent = "▶";
                this.ui.btnPlay.childNodes[2].textContent = " Start";
                this.ui.btnPlay.className = "col-span-1 py-2 bg-emerald-600 hover:bg-emerald-500 text-white rounded font-bold shadow transition flex justify-center items-center gap-1";

                if (this.scenario === 'projectile') {
                    const v0 = parseFloat(this.ui.v0.value);
                    const ang = parseFloat(this.ui.angle.value) * Math.PI / 180;
                    this.initialState = [0, 0, v0 * Math.cos(ang), v0 * Math.sin(ang)];
                    this.stateEuler = [...this.initialState];
                    this.stateRK4 = [...this.initialState];
                } else {
                    const v = parseFloat(this.ui.orbV.value);
                    const r = 200;
                    const vCirc = Math.sqrt(G_CONST * M_BODY / r); 
                    const vy = v * vCirc;
                    
                    this.initialState = [r, 0, 0, vy];
                    this.stateEuler = [...this.initialState];
                    this.stateRK4 = [...this.initialState];
                    this.stateTrue = [...this.initialState];
                    
                    // Initial bounds check
                    this.checkBounds(r, 0);
                }
                
                this.draw();
            }

            checkBounds(x, y) {
                if (this.scenario === 'projectile') {
                    if (x > this.viewBounds.maxX) this.viewBounds.maxX = x;
                    if (y > this.viewBounds.maxY) this.viewBounds.maxY = y;
                } else {
                    // For orbit, track max radius from center
                    const r = Math.sqrt(x*x + y*y); // Distance from center
                    // Or simpler rectangular bounds, but radial fits "zoom" better
                    // Actually, let's just track max coordinate for square scaling
                    const maxCoord = Math.max(Math.abs(x), Math.abs(y));
                    if (maxCoord > this.viewBounds.maxR) this.viewBounds.maxR = maxCoord;
                }
            }

            update() {
                if (!this.isRunning) return;

                const h = parseFloat(this.ui.h.value);
                const stepsPerFrame = parseInt(this.ui.speed.value);

                for (let s = 0; s < stepsPerFrame; s++) {
                    // Update Physics
                    if (this.scenario === 'projectile') {
                        this.stateEuler = eulerStep(this.stateEuler, projectileDerivs, h);
                        this.stateRK4 = rk4Step(this.stateRK4, projectileDerivs, h);
                        this.t += h;

                        const v0 = parseFloat(this.ui.v0.value);
                        const ang = parseFloat(this.ui.angle.value) * Math.PI / 180;
                        const truePos = projectileAnalytic(this.t, v0, ang);
                        
                        // Bounds update
                        this.checkBounds(this.stateEuler[0], this.stateEuler[1]);
                        this.checkBounds(this.stateRK4[0], this.stateRK4[1]);
                        this.checkBounds(truePos.x, truePos.y);

                        // Stop if ground hit
                        if (truePos.y < -50 && this.stateEuler[1] < -50 && this.stateRK4[1] < -50) {
                            this.isRunning = false;
                            break;
                        }

                        // Errors
                        const dxE = this.stateEuler[0] - truePos.x;
                        const dyE = this.stateEuler[1] - truePos.y;
                        const errE = Math.sqrt(dxE*dxE + dyE*dyE);

                        const dxR = this.stateRK4[0] - truePos.x;
                        const dyR = this.stateRK4[1] - truePos.y;
                        const errR = Math.sqrt(dxR*dxR + dyR*dyR);

                        this.errors.push({ t: this.t, errEuler: errE, errRK4: errR });

                    } else { // Orbit
                        this.stateEuler = eulerStep(this.stateEuler, orbitDerivs, h);
                        this.stateRK4 = rk4Step(this.stateRK4, orbitDerivs, h);
                        this.stateTrue = highResStep(this.stateTrue, h);
                        this.t += h;

                        // Bounds update
                        this.checkBounds(this.stateEuler[0], this.stateEuler[1]);
                        this.checkBounds(this.stateRK4[0], this.stateRK4[1]);
                        this.checkBounds(this.stateTrue[0], this.stateTrue[1]);

                        // Errors
                        const dxE = this.stateEuler[0] - this.stateTrue[0];
                        const dyE = this.stateEuler[1] - this.stateTrue[1];
                        const errE = Math.sqrt(dxE*dxE + dyE*dyE);

                        const dxR = this.stateRK4[0] - this.stateTrue[0];
                        const dyR = this.stateRK4[1] - this.stateTrue[1];
                        const errR = Math.sqrt(dxR*dxR + dyR*dyR);

                        this.errors.push({ t: this.t, errEuler: errE, errRK4: errR });
                    }

                    if (this.t % (h*5) < h) { 
                        this.pathEuler.push({x: this.stateEuler[0], y: this.stateEuler[1]});
                        this.pathRK4.push({x: this.stateRK4[0], y: this.stateRK4[1]});
                        if (this.scenario === 'orbit') {
                            this.pathTrue.push({x: this.stateTrue[0], y: this.stateTrue[1]});
                        }
                    }
                }
                
                this.ui.timeDisplay.textContent = this.t.toFixed(2);
            }

            draw() {
                // Clear
                this.ctxSim.fillStyle = '#000000';
                this.ctxSim.fillRect(0, 0, this.simCanvas.width, this.simCanvas.height);
                
                // --- Transformation Logic ---
                const w = this.simCanvas.width;
                const h = this.simCanvas.height;
                let toCanvas;

                if (this.scenario === 'projectile') {
                    // Add 10% padding
                    const logicalW = this.viewBounds.maxX * 1.1;
                    const logicalH = this.viewBounds.maxY * 1.2; // A bit more for ground clearance
                    
                    // Maintain aspect ratio relative to available space
                    // We want: logicalW fits in w, logicalH fits in h
                    const scaleX = w / logicalW;
                    const scaleY = h / logicalH;
                    const scale = Math.min(scaleX, scaleY); // fit both

                    // Origin (0,0) position:
                    // x=0 is at left padding (e.g. 30px)
                    // y=0 is at bottom padding (e.g. 30px)
                    const xOffset = 40;
                    const yOffset = h - 40;

                    toCanvas = (x, y) => {
                        return { 
                            x: xOffset + x * scale, 
                            y: yOffset - y * scale 
                        };
                    };
                    
                    // Draw Ground line
                    this.ctxSim.strokeStyle = '#4b5563';
                    this.ctxSim.beginPath();
                    this.ctxSim.moveTo(0, yOffset);
                    this.ctxSim.lineTo(w, yOffset);
                    this.ctxSim.stroke();

                } else {
                    // Orbit: Center is (w/2, h/2)
                    // Scale based on max radius + padding
                    const range = this.viewBounds.maxR * 1.2; // 20% padding
                    // Range needs to cover -range to +range, so total logic width is range*2
                    const scale = Math.min(w, h) / (range * 2);
                    
                    const cx = w/2;
                    const cy = h/2;

                    toCanvas = (x, y) => {
                        return { 
                            x: cx + x * scale, 
                            y: cy - y * scale 
                        };
                    };
                    
                    // Draw Sun
                    this.ctxSim.fillStyle = '#f59e0b';
                    this.ctxSim.beginPath();
                    this.ctxSim.arc(cx, cy, 8, 0, Math.PI*2); // Sun size fixed in pixels or scale? Fixed is better for visibility
                    this.ctxSim.fill();
                    this.ctxSim.shadowBlur = 15;
                    this.ctxSim.shadowColor = '#f59e0b';
                    this.ctxSim.stroke();
                    this.ctxSim.shadowBlur = 0;
                }

                // Draw Truth Path (Ghost)
                this.ctxSim.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctxSim.lineWidth = 4;
                if (this.scenario === 'projectile') {
                    const v0 = parseFloat(this.ui.v0.value);
                    const ang = parseFloat(this.ui.angle.value) * Math.PI / 180;
                    this.ctxSim.beginPath();
                    // Dynamically draw analytic curve based on bounds
                    // Approximate end time t_end = 2 * v0_y / g
                    const v0y = v0 * Math.sin(ang);
                    const tEnd = (2 * v0y / G_EARTH) * 1.2; // +20%
                    
                    for(let t=0; t<tEnd; t+=0.1) {
                        const p = projectileAnalytic(t, v0, ang);
                        const cp = toCanvas(p.x, p.y);
                        if(t===0) this.ctxSim.moveTo(cp.x, cp.y);
                        else this.ctxSim.lineTo(cp.x, cp.y);
                    }
                    this.ctxSim.stroke();
                } else {
                    // Draw True Orbit Path
                    this.ctxSim.beginPath();
                    this.pathTrue.forEach((p, i) => {
                         const cp = toCanvas(p.x, p.y);
                         if(i===0) this.ctxSim.moveTo(cp.x, cp.y);
                         else this.ctxSim.lineTo(cp.x, cp.y);
                    });
                    this.ctxSim.stroke();
                }

                // Draw Euler (Red)
                this.drawPathAndActor(this.ctxSim, this.pathEuler, this.stateEuler, '#ef4444', toCanvas);

                // Draw RK4 (Green)
                this.drawPathAndActor(this.ctxSim, this.pathRK4, this.stateRK4, '#22c55e', toCanvas);

                // Draw Chart
                this.drawChart();
            }

            drawPathAndActor(ctx, path, state, color, transform) {
                if (path.length < 1) return;
                
                // Trail
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                path.forEach((p, i) => {
                    const cp = transform(p.x, p.y);
                    if(i===0) ctx.moveTo(cp.x, cp.y);
                    else ctx.lineTo(cp.x, cp.y);
                });
                ctx.stroke();

                // Dots
                ctx.fillStyle = color;
                // Render fewer dots if zoomed out heavily to avoid clutter? 
                // Currently just last 50 steps
                const limit = Math.max(0, path.length - 100);
                for(let i=path.length-1; i>=limit; i-=2) {
                     const p = path[i];
                     const cp = transform(p.x, p.y);
                     ctx.globalAlpha = 0.5;
                     ctx.beginPath();
                     ctx.arc(cp.x, cp.y, 2, 0, Math.PI*2);
                     ctx.fill();
                }
                ctx.globalAlpha = 1.0;

                // Current Head
                const head = transform(state[0], state[1]);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(head.x, head.y, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            drawChart() {
                const ctx = this.ctxChart;
                const w = this.chartCanvas.width;
                const h = this.chartCanvas.height;

                // Clear
                ctx.fillStyle = '#111827'; // Gray 900
                ctx.fillRect(0, 0, w, h);

                if (this.errors.length === 0) return;

                const maxT = this.t;
                let maxErr = 0;
                this.errors.forEach(e => {
                    if(e.errEuler > maxErr) maxErr = e.errEuler;
                    if(e.errRK4 > maxErr) maxErr = e.errRK4;
                });
                
                if(maxErr === 0) maxErr = 1;

                const padding = 20;
                const graphW = w - padding * 2;
                const graphH = h - padding * 2;

                const toChart = (t, err) => {
                    const x = padding + (t / maxT) * graphW;
                    const y = h - padding - (err / maxErr) * graphH;
                    return {x, y};
                }

                // Grid lines
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, padding); ctx.lineTo(padding, h-padding); 
                ctx.moveTo(padding, h-padding); ctx.lineTo(w-padding, h-padding); 
                ctx.stroke();
                
                // Euler (Red)
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.errors.forEach((e, i) => {
                    const p = toChart(e.t, e.errEuler);
                    if(i===0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                // RK4 (Green)
                ctx.strokeStyle = '#22c55e';
                ctx.beginPath();
                this.errors.forEach((e, i) => {
                    const p = toChart(e.t, e.errRK4);
                    if(i===0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                // Text Labels
                ctx.fillStyle = '#9ca3af';
                ctx.font = '10px monospace';
                ctx.fillText(`Max Err: ${maxErr.toFixed(2)}m`, padding + 5, padding + 10);
            }

            resize() {
                const p1 = this.simCanvas.parentElement;
                this.simCanvas.width = p1.clientWidth;
                this.simCanvas.height = p1.clientHeight;
                
                const p2 = this.chartCanvas.parentElement;
                this.chartCanvas.width = p2.clientWidth;
                this.chartCanvas.height = p2.clientHeight;

                this.draw();
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        window.app = new App();
    } 
    </script>
</body>
</html>
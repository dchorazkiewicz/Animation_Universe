<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveLab Pro - Symulator Fal</title>
    <!-- Tailwind CSS do stylowania -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; color: #e2e8f0; font-family: sans-serif; }
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #10b981;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
        .icon { width: 18px; height: 18px; display: inline-block; vertical-align: middle; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Header -->
    <header class="flex items-center justify-between px-6 py-4 bg-slate-900 border-b border-slate-800 shrink-0">
        <div class="flex items-center gap-3">
            <div class="p-2 bg-emerald-500/10 rounded-lg">
                <!-- Icon Waves -->
                <svg class="text-emerald-500 w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 6c.6.5 1.2 1 2.5 1C7 7 7 5 9.5 5c2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"/><path d="M2 12c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"/><path d="M2 18c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"/></svg>
            </div>
            <div>
                <h1 class="text-xl font-bold text-white tracking-tight">WaveLab <span class="text-emerald-500">Pro</span></h1>
                <p class="text-xs text-slate-400">Interaktywny symulator fizyki falowej</p>
            </div>
        </div>
        
        <nav class="flex gap-1" id="nav-buttons">
            <!-- Buttons generated by JS -->
        </nav>
    </header>

    <!-- Main Content -->
    <main class="flex flex-1 overflow-hidden">
        
        <!-- Sidebar -->
        <aside class="w-80 bg-slate-900 border-r border-slate-800 p-6 flex flex-col gap-8 overflow-y-auto shrink-0 z-10">
            
            <div class="space-y-6">
                <div class="flex items-center justify-between mb-2">
                    <h2 class="text-sm font-bold text-slate-100 uppercase tracking-wider flex items-center gap-2">
                        <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
                        Parametry
                    </h2>
                </div>

                <div class="bg-slate-800/50 p-4 rounded-xl border border-slate-700/50 space-y-6">
                    
                    <!-- Global ZOOM -->
                    <div class="pb-4 border-b border-slate-700/50">
                        <div class="flex items-center gap-2 text-emerald-400 mb-2">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
                            <span class="text-xs font-bold uppercase">Widok</span>
                        </div>
                        <div class="flex flex-col gap-1">
                            <div class="flex justify-between text-xs text-slate-400 font-medium uppercase tracking-wider">
                                <span>Zoom</span>
                                <span id="val-zoom">1.0x</span>
                            </div>
                            <input type="range" id="inp-zoom" min="0.5" max="1.5" step="0.1" value="1.0">
                        </div>
                    </div>

                    <!-- Controls Container (Dynamic) -->
                    <div id="controls-container" class="space-y-6">
                        <!-- Sliders injected by JS -->
                    </div>
                </div>
                
                <div id="info-box" class="p-4 bg-slate-800/30 rounded-xl text-xs text-slate-400 leading-relaxed border border-slate-800">
                    <!-- Text injected by JS -->
                </div>

            </div>

            <div class="mt-auto space-y-3">
                 <div class="grid grid-cols-2 gap-2">
                    <button id="btn-play" class="flex items-center justify-center gap-2 px-4 py-2 rounded-lg font-medium bg-emerald-600 hover:bg-emerald-500 text-white shadow-lg shadow-emerald-900/20 transition-all">
                        <svg id="icon-pause" class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                        <span id="txt-play">Pauza</span>
                    </button>
                    
                    <button id="btn-reset" class="flex items-center justify-center gap-2 px-4 py-2 rounded-lg font-medium border border-slate-600 hover:bg-slate-700 text-slate-300 transition-all">
                        <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        Reset
                    </button>
                 </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <div class="flex-1 relative bg-slate-950 flex items-center justify-center overflow-hidden">
            <canvas id="simCanvas" class="w-full h-full cursor-crosshair"></canvas>
            
            <div class="absolute bottom-6 right-6 bg-slate-900/90 backdrop-blur border border-slate-700 p-4 rounded-xl max-w-sm shadow-2xl pointer-events-none select-none">
                <h3 class="font-bold text-emerald-400 mb-1 flex items-center gap-2">
                    <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
                    Co widzisz?
                </h3>
                <p id="overlay-text" class="text-sm text-slate-300 leading-relaxed">
                    Opis symulacji...
                </p>
            </div>
        </div>

    </main>

<script>
    // --- STATE MANAGEMENT ---
    const state = {
        activeTab: 'huygens', // 'huygens', 'diffraction', 'interference'
        isPlaying: true,
        time: 0,
        // Simulation params
        density: 15,
        waveSpeed: 1.0,
        zoom: 1.0,
        // Slit params
        slitWidth: 60,
        slitSpacing: 100,
        numSlits: 2
    };

    // Constants
    const WAVELENGTH = 40;
    const BARRIER_X = 200;

    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const controlsContainer = document.getElementById('controls-container');
    const navButtonsContainer = document.getElementById('nav-buttons');
    const overlayText = document.getElementById('overlay-text');
    const infoBox = document.getElementById('info-box');
    const btnPlay = document.getElementById('btn-play');
    const btnReset = document.getElementById('btn-reset');
    const txtPlay = document.getElementById('txt-play');
    const iconPause = document.getElementById('icon-pause');
    const inpZoom = document.getElementById('inp-zoom');
    const valZoom = document.getElementById('val-zoom');

    // --- SETUP & EVENTS ---

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        // We handle scaling inside the draw loop using ctx.scale()
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    btnPlay.addEventListener('click', () => {
        state.isPlaying = !state.isPlaying;
        updatePlayButton();
    });

    btnReset.addEventListener('click', () => {
        state.time = 0;
        state.isPlaying = true;
        updatePlayButton();
    });

    function updatePlayButton() {
        if (state.isPlaying) {
            txtPlay.textContent = "Pauza";
            iconPause.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
            btnPlay.classList.add("bg-emerald-600", "text-white");
            btnPlay.classList.remove("bg-slate-700", "text-slate-200");
        } else {
            txtPlay.textContent = "Start";
            iconPause.innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';
            btnPlay.classList.remove("bg-emerald-600", "text-white");
            btnPlay.classList.add("bg-slate-700", "text-slate-200");
        }
    }

    inpZoom.addEventListener('input', (e) => {
        state.zoom = parseFloat(e.target.value);
        valZoom.textContent = state.zoom.toFixed(1) + 'x';
    });

    // --- TABS & UI GENERATION ---

    const tabs = [
        { id: 'huygens', label: 'Zasada Huygensa', icon: '<path d="M22 12h-4l-3 9L9 3l-3 9H2"/>' },
        { id: 'diffraction', label: 'Dyfrakcja', icon: '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>' },
        { id: 'interference', label: 'Interferencja', icon: '<line x1="21" y1="10" x2="3" y2="10"/><line x1="21" y1="6" x2="3" y2="6"/><line x1="21" y1="14" x2="3" y2="14"/><line x1="21" y1="18" x2="3" y2="18"/>' }
    ];

    function renderTabs() {
        navButtonsContainer.innerHTML = '';
        tabs.forEach(tab => {
            const btn = document.createElement('button');
            const isActive = state.activeTab === tab.id;
            btn.className = `flex items-center gap-2 px-6 py-4 border-b-2 transition-colors ${
                isActive 
                ? "border-emerald-500 text-emerald-400 bg-slate-800/50" 
                : "border-transparent text-slate-400 hover:text-slate-200 hover:bg-slate-800/30"
            }`;
            btn.innerHTML = `<svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${tab.icon}</svg> <span class="font-medium">${tab.label}</span>`;
            btn.onclick = () => {
                state.activeTab = tab.id;
                state.time = 0;
                renderTabs();
                renderControls();
                updateInfoText();
            };
            navButtonsContainer.appendChild(btn);
        });
    }

    function createSlider(id, label, min, max, step, unit, initialVal, onChange) {
        const wrapper = document.createElement('div');
        wrapper.className = "flex flex-col gap-1";
        
        const header = document.createElement('div');
        header.className = "flex justify-between text-xs text-slate-400 font-medium uppercase tracking-wider";
        header.innerHTML = `<span>${label}</span><span id="val-${id}">${initialVal}${unit}</span>`;
        
        const input = document.createElement('input');
        input.type = "range";
        input.min = min;
        input.max = max;
        input.step = step;
        input.value = initialVal;
        
        input.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById(`val-${id}`).innerText = val + unit;
            onChange(val);
        });

        wrapper.appendChild(header);
        wrapper.appendChild(input);
        return wrapper;
    }

    function renderControls() {
        controlsContainer.innerHTML = '';
        
        if (state.activeTab === 'interference') {
            controlsContainer.appendChild(createSlider('numSlits', 'Liczba Szczelin (N)', 2, 5, 1, '', state.numSlits, v => state.numSlits = v));
            controlsContainer.appendChild(createSlider('slitSpacing', 'Rozstaw Środków (d)', 50, 150, 1, ' px', state.slitSpacing, v => {
                state.slitSpacing = v;
                // Re-validate slitWidth
                if (state.slitWidth > state.slitSpacing) {
                    state.slitWidth = state.slitSpacing;
                    // Note: would need to update UI value here ideally, but simple re-render works
                    renderControls(); 
                } else {
                    renderControls(); // Re-render to update max constraint on width slider
                }
            }));
        }

        if (state.activeTab !== 'huygens') {
             const maxW = state.activeTab === 'interference' ? state.slitSpacing : 200;
             controlsContainer.appendChild(createSlider('slitWidth', 'Szerokość Szczeliny (a)', 10, maxW, 1, ' px', state.slitWidth, v => state.slitWidth = v));
        }

        controlsContainer.appendChild(createSlider('density', 'Gęstość (Dokładność)', 5, 55, 1, ' pts', state.density, v => state.density = v));
        controlsContainer.appendChild(createSlider('speed', 'Prędkość fali', 0.2, 5, 0.1, '', state.waveSpeed, v => state.waveSpeed = v));
    }

    function updateInfoText() {
        if (state.activeTab === 'huygens') {
            infoBox.innerText = "Zwiększ gęstość, aby zobaczyć jak pojedyncze fale kuliste tworzą czoło fali. Użyj suwaka Zoom, aby zobaczyć większy obszar.";
            overlayText.innerText = "Propagacja swobodna. Oddal widok, aby zobaczyć jak fala rozchodzi się w nieskończoność.";
        } else if (state.activeTab === 'diffraction') {
            infoBox.innerText = "Obserwuj czerwony wykres (profil natężenia). Węższa szczelina powoduje szersze rozmycie (silniejszą dyfrakcję).";
            overlayText.innerText = "Dyfrakcja na pojedynczej szczelinie. Czerwony wykres pokazuje rozkład natężenia na ekranie.";
        } else {
            infoBox.innerText = "Wzór interferencyjny zależy od liczby szczelin. Oddal widok (Zoom < 1.0), aby zobaczyć więcej prążków bocznych.";
            overlayText.innerText = `Interferencja na ${state.numSlits} szczelinach. Użyj ZOOM, aby zobaczyć boczne maksima interferencyjne.`;
        }
    }

    // --- ANIMATION LOOP ---

    function animate() {
        if (state.isPlaying) {
            state.time += 1;
        }

        const dpr = window.devicePixelRatio || 1;
        const width = canvas.width / dpr;
        const height = canvas.height / dpr;

        // Reset transform & clear
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.scale(dpr, dpr);
        ctx.fillStyle = '#0f172a'; // slate-900
        ctx.fillRect(0, 0, width, height);

        const centerX = width / 2;
        const centerY = height / 2;

        // --- ZOOM TRANSFORM ---
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(state.zoom, state.zoom);
        ctx.translate(-centerX, -centerY);

        // Calculate world bounds
        const worldLeft = centerX - (centerX / state.zoom);
        const worldTop = centerY - (centerY / state.zoom);
        const worldRight = centerX + (width - centerX)/state.zoom;
        const worldBottom = centerY + (height - centerY)/state.zoom;

        const maxVisibleRadius = Math.hypot(
            Math.max(Math.abs(worldLeft - centerX), Math.abs(worldRight - centerX)), 
            Math.max(Math.abs(worldTop - centerY), Math.abs(worldBottom - centerY))
        );

        // --- RENDER LOGIC ---

        if (state.activeTab === 'huygens') {
            const spacing = 60 - state.density; 
            
            // Source
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#10b981'; 
            ctx.fill();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#10b981';
            ctx.fill();
            ctx.shadowBlur = 0;

            const mainWaveRadius = state.time * state.waveSpeed;
            const margin = 50;

            for (let x = worldLeft - margin; x <= worldRight + margin; x += spacing) {
                const gridX = Math.round(x / spacing) * spacing;
                for (let y = worldTop - margin; y <= worldBottom + margin; y += spacing) {
                    const gridY = Math.round(y / spacing) * spacing;
                    const dist = Math.hypot(gridX - centerX, gridY - centerY);
                    
                    if (mainWaveRadius >= dist) {
                        const timeSinceActivation = (mainWaveRadius - dist) / state.waveSpeed;
                        const waveletRadius = timeSinceActivation * state.waveSpeed;
                        const opacity = Math.max(0, 1 - waveletRadius / 100); 

                        if (opacity > 0.05) {
                            ctx.beginPath();
                            ctx.arc(gridX, gridY, waveletRadius, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgba(148, 163, 184, ${opacity * 0.5})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        if (waveletRadius < 20) {
                           ctx.beginPath();
                           ctx.arc(gridX, gridY, 2, 0, Math.PI * 2);
                           ctx.fillStyle = `rgba(56, 189, 248, ${1 - waveletRadius/20})`;
                           ctx.fill();
                        }
                    } else {
                        // Resting points (optional optimization: skip drawing if too zoomed out)
                        if (state.zoom > 0.4) {
                            ctx.beginPath();
                            ctx.arc(gridX, gridY, 1, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                            ctx.fill();
                        }
                    }
                }
            }
            
            // Main wave front
            if (mainWaveRadius < maxVisibleRadius) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, mainWaveRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        } 
        else { // Diffraction & Interference
            const spacing = Math.max(3, (60 - state.density) / 2); 
            const sources = [];
            const phase = (state.time * state.waveSpeed) % WAVELENGTH;
            
            const N = state.activeTab === 'diffraction' ? 1 : state.numSlits;
            const effectiveWidth = state.activeTab === 'diffraction' ? state.slitWidth : Math.min(state.slitWidth, state.slitSpacing);
            const effectiveSpacing = state.activeTab === 'diffraction' ? 0 : state.slitSpacing;

            ctx.fillStyle = '#475569'; 

            const arrayHeight = (N - 1) * effectiveSpacing;
            const firstSlitCenterY = centerY - arrayHeight / 2;

            // Barrier Top
            const firstSlitTop = firstSlitCenterY - effectiveWidth / 2;
            ctx.fillRect(BARRIER_X, worldTop - 100, 10, Math.max(0, firstSlitTop - (worldTop - 100)));

            // Barrier Bottom
            const lastSlitBottom = (firstSlitCenterY + (N - 1) * effectiveSpacing) + effectiveWidth / 2;
            ctx.fillRect(BARRIER_X, lastSlitBottom, 10, Math.max(0, (worldBottom + 100) - lastSlitBottom));

            for (let i = 0; i < N; i++) {
                const currentSlitCenterY = firstSlitCenterY + i * effectiveSpacing;
                const slitTop = currentSlitCenterY - effectiveWidth / 2;
                const slitBottom = currentSlitCenterY + effectiveWidth / 2;

                for (let y = slitTop + spacing/2; y <= slitBottom; y += spacing) {
                    if (y < slitBottom) {
                        sources.push({ x: BARRIER_X, y: y });
                    }
                }
                
                if (i < N - 1) {
                    const nextSlitTop = (currentSlitCenterY + effectiveSpacing) - effectiveWidth / 2;
                    ctx.fillRect(BARRIER_X, slitBottom, 10, Math.max(0, nextSlitTop - slitBottom));
                }
            }

            // Incoming Plane Wave
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            
            let startX = BARRIER_X + phase;
            while (startX > BARRIER_X) startX -= WAVELENGTH;

            for (let x = startX; x > worldLeft; x -= WAVELENGTH) {
                ctx.moveTo(x, worldTop);
                ctx.lineTo(x, worldBottom);
            }
            ctx.stroke();

            // Huygens sources drawing
            const drawSkip = sources.length > 50 ? 2 : 1; 

            sources.forEach((source, index) => {
                if (index % drawSkip !== 0) return;

                ctx.beginPath();
                ctx.arc(source.x, source.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = '#38bdf8'; 
                ctx.fill();

                const maxR = maxVisibleRadius + 200;
                ctx.beginPath();
                ctx.strokeStyle = `rgba(148, 163, 184, ${0.08 * (20/sources.length)})`; 
                
                for (let r = phase; r < maxR; r += WAVELENGTH) {
                    ctx.moveTo(source.x + r * Math.cos(-Math.PI/2), source.y + r * Math.sin(-Math.PI/2));
                    ctx.arc(source.x, source.y, r, -Math.PI/2, Math.PI/2);
                }
                ctx.stroke();
            });

            // Intensity Plot
            const defaultScreenX = width - 50; 
            
            ctx.beginPath();
            ctx.moveTo(defaultScreenX, worldTop);
            ctx.lineTo(defaultScreenX, worldBottom);
            ctx.strokeStyle = '#94a3b8';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3 / state.zoom;

            const k = (2 * Math.PI) / WAVELENGTH;
            const stepY = 3; 
            
            let first = true;
            for (let sy = worldTop; sy <= worldBottom; sy += stepY) {
                let real = 0;
                let imag = 0;

                for (let s of sources) {
                    const dist = Math.hypot(defaultScreenX - s.x, sy - s.y);
                    const phi = k * dist;
                    real += Math.cos(phi);
                    imag += Math.sin(phi);
                }

                const intensity = (real * real + imag * imag);
                const plotValue = (intensity / (sources.length * sources.length)) * (state.activeTab === 'interference' ? 250 : 150);
                const plotX = defaultScreenX - plotValue; 
                
                if (first) {
                    ctx.moveTo(plotX, sy);
                    first = false;
                } else {
                    ctx.lineTo(plotX, sy);
                }
            }
            ctx.stroke();

            // Label
            ctx.save();
            ctx.translate(defaultScreenX - 80, worldTop + 40);
            ctx.scale(1/state.zoom, 1/state.zoom);
            ctx.fillStyle = '#94a3b8';
            ctx.font = '14px sans-serif';
            ctx.fillText('Natężenie I(y)', 0, 0);
            ctx.restore();
        }

        ctx.restore(); // Restore zoom transform
        requestAnimationFrame(animate);
    }

    // --- INIT ---
    renderTabs();
    renderControls();
    updateInfoText();
    updatePlayButton();
    animate();

</script>
</body>
</html>
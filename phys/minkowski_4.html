<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Od Czarnej Dziury do Minkowskiego</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #050505;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 { margin: 15px 0 5px 0; font-size: 1.4rem; letter-spacing: 1px; text-transform: uppercase; color: #fff; }
        p { color: #888; font-size: 0.9rem; margin-bottom: 20px; text-align: center;}

        .container {
            position: relative;
            width: 95vw;
            height: 75vh;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
            background: #000;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(5px);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 300px;
            pointer-events: none;
        }
        
        .ui-element { pointer-events: auto; }
        .slider-group { margin-bottom: 20px; }
        label { display: block; font-size: 0.85rem; color: #aaa; margin-bottom: 8px; }
        input[type=range] { width: 100%; accent-color: #ffaa00; cursor: pointer; }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: #ccc;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

        .status-panel {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-family: monospace;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .zone-label {
            position: absolute;
            bottom: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>

    <h1>Od Czarnej Dziury do Minkowskiego</h1>
    <p>Przesuń obserwatora w prawo, aby zobaczyć jak czasoprzestrzeń się "prostuje" (zanik grawitacji).</p>

    <div class="container" id="canvasContainer">
        <canvas id="grCanvas"></canvas>
        
        <!-- Background Text Labels -->
        <div class="zone-label" style="left: 20px;">GRAWITACJA (Silna)</div>
        <div class="zone-label" style="right: 20px;">MINKOWSKI (Płaska)</div>

        <div class="ui-overlay">
            <div class="slider-group ui-element">
                <label>Masa Czarnej Dziury (M)</label>
                <!-- Domyślnie mniejsza masa, żeby zmieścić więcej "przestrzeni" -->
                <input type="range" id="massSlider" min="10" max="60" value="25">
            </div>

            <div class="legend-item"><span class="dot" style="background:rgba(68, 136, 255, 0.8)"></span> Stożek Świetlny</div>
            <div class="legend-item"><span class="dot" style="background:#ffaa00"></span> Promienie Światła</div>
            <div class="legend-item"><span class="dot" style="background:#fff; border:1px solid #444;"></span> Obserwator</div>
            
            <div class="status-panel">
                Promień r: <span id="rVal" style="color:#fff">0.00</span> M<br>
                Prędkość rzeki: <span id="betaVal" style="color:#ffaa00">0.00</span> c<br>
                <small id="zoneText" style="color:#888">...</small>
            </div>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('grCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');

        // Physics Constants
        let M = 25; // Mniejsza domyślna masa pozwala pokazać większy dystans
        let horizonR = 2 * M;
        
        // Observer Position
        let obs = { x: 600, y: 350, dragging: false };
        
        // Rays for background visualization
        let rays = [];
        const NUM_RAYS = 25; // Więcej promieni

        // --- SETUP ---
        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            initRays();
        }
        window.addEventListener('resize', resize);

        // --- PHYSICS: GULLSTRAND-PAINLEVE ---
        // beta = sqrt(2M/r) is the velocity of space falling in.
        // Outgoing light speed (relative to grid) = 1 - beta
        // Ingoing light speed (relative to grid) = -1 - beta
        
        function getMetricData(r) {
            if (r < 0.1) r = 0.1; // Avoid singularity crash
            
            const beta = Math.sqrt((2 * M) / r); // Escape velocity at r
            
            // Local light cones slope
            const slopeOut = 1 - beta;  // Right edge of cone
            const slopeIn = -1 - beta;  // Left edge of cone
            
            return { beta, slopeOut, slopeIn };
        }

        function initRays() {
            rays = [];
            for(let i=0; i<NUM_RAYS; i++) {
                rays.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    type: i % 2 === 0 ? 'out' : 'in', // mixing ingoing/outgoing
                    offset: Math.random() * 100
                });
            }
        }

        // --- DRAWING ---
        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const singX = 50; // Singularity position (left margin)

            // 1. CLEAR & BACKGROUND
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Update Horizon
            horizonR = 2 * M;
            const horizonX = singX + horizonR;

            // 2. DRAW ZONES (Singularity & Horizon)
            // Singularity
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, horizonX, h);
            
            // Horizon Line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(horizonX, 0);
            ctx.lineTo(horizonX, h);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#555';
            ctx.font = '12px monospace';
            ctx.fillText("HORYZONT (r=2M)", horizonX + 5, 20);

            // 3. DRAW GEODESICS (Background Flow)
            // We draw paths of photons to visualize curvature
            ctx.strokeStyle = 'rgba(255, 170, 0, 0.4)'; // Jaśniejszy żółty
            ctx.lineWidth = 1.5;

            rays.forEach(ray => {
                ctx.beginPath();
                
                // Tracing a segment of the ray
                let cx = ray.x;
                let cy = ray.y;
                
                // Move 'ray' forward for animation
                // Time flows UP on screen (standard diagram convention is Time Y-axis)
                // But let's make flow downwards for "falling"? 
                // Let's stick to: Y is Time (UP).
                
                ray.y -= 1.5; // Move up in time

                // Apply Metric to move X
                let r = ray.x - singX;
                let m = getMetricData(r);
                let dx = (ray.type === 'out' ? m.slopeOut : m.slopeIn) * 1.5;
                ray.x += dx;

                // Reset loop
                if (ray.y < 0 || ray.x < singX + 2 || ray.x > w) {
                    ray.y = h;
                    ray.x = singX + 5 + Math.random() * (w - singX);
                }

                // Draw trail (integral curve) backward
                let tx = ray.x;
                let ty = ray.y;
                ctx.moveTo(tx, ty);

                for(let k=0; k<15; k++) {
                    let tr = tx - singX;
                    if(tr < 1) break;
                    
                    let tm = getMetricData(tr);
                    let slope = (ray.type === 'out' ? tm.slopeOut : tm.slopeIn);
                    
                    tx -= slope * 5; // back in X
                    ty += 5;         // back in Time (down)
                    ctx.lineTo(tx, ty);
                }
                ctx.stroke();
            });

            // 4. OBSERVER & CONE
            const obsR = obs.x - singX;
            const obsM = getMetricData(obsR);
            
            // UI Update
            const rInM = obsR / M;
            document.getElementById('rVal').innerText = rInM.toFixed(1);
            document.getElementById('betaVal').innerText = obsM.beta.toFixed(3);
            
            const zoneText = document.getElementById('zoneText');
            if (obsR < horizonR) {
                zoneText.innerText = "WEWNĄTRZ CZARNEJ DZIURY\nStożki skierowane do osobliwości.";
                zoneText.style.color = "#ff4444";
            } else if (rInM > 15) {
                zoneText.innerText = "STREFA MINKOWSKIEGO\nCzasoprzestrzeń prawie płaska.";
                zoneText.style.color = "#4488ff";
            } else {
                zoneText.innerText = "ZAKRZYWIONA CZASOPRZESTRZEŃ\nZauważalne przechylenie stożków.";
                zoneText.style.color = "#e0e0e0";
            }


            // Draw Light Cone
            const coneH = 100; // Height of cone in pixels (Time duration)
            
            // Right edge of cone (Outgoing photon)
            const dxRight = obsM.slopeOut * coneH;
            const pRightX = obs.x + dxRight;
            const pRightY = obs.y - coneH;
            
            // Left edge of cone (Ingoing photon)
            const dxLeft = obsM.slopeIn * coneH;
            const pLeftX = obs.x + dxLeft;
            const pLeftY = obs.y - coneH;

            // Gradient for cone body
            const coneGrad = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y - coneH);
            coneGrad.addColorStop(0, 'rgba(68, 136, 255, 0.7)');
            coneGrad.addColorStop(1, 'rgba(68, 136, 255, 0.1)');

            ctx.fillStyle = coneGrad;
            ctx.beginPath();
            ctx.moveTo(obs.x, obs.y); // Vertex
            ctx.lineTo(pRightX, pRightY);
            ctx.lineTo(pLeftX, pLeftY);
            ctx.closePath();
            ctx.fill();
            
            // Outline
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(obs.x, obs.y); ctx.lineTo(pRightX, pRightY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(obs.x, obs.y); ctx.lineTo(pLeftX, pLeftY); ctx.stroke();
            
            // 5. MINKOWSKI REFERENCE (Vertical Line Guide)
            // Shows "Straight Up" (Time in flat space) vs "Local Time" (Tilted)
            // In GP coords, the stationary observer moves at -beta relative to the river.
            // So the "axis of time" for the observer is tilted left.
            const tiltX = obs.x - (obsM.beta * coneH);
            
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.setLineDash([2,4]);
            ctx.beginPath();
            ctx.moveTo(obs.x, obs.y);
            ctx.lineTo(tiltX, obs.y - coneH);
            ctx.stroke();
            ctx.setLineDash([]);

            // Observer Dot
            ctx.beginPath();
            ctx.arc(obs.x, obs.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();

            // Glow if interacting
            if(obs.dragging) {
                ctx.beginPath(); ctx.arc(obs.x, obs.y, 12, 0, Math.PI*2);
                ctx.strokeStyle = '#fff'; ctx.stroke();
            }

            requestAnimationFrame(draw);
        }

        // --- INTERACTION ---
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            return { x: e.clientX - r.left, y: e.clientY - r.top };
        }

        canvas.addEventListener('mousedown', e => {
            const p = getPos(e);
            if(Math.hypot(p.x - obs.x, p.y - obs.y) < 30) obs.dragging = true;
        });
        
        window.addEventListener('mousemove', e => {
            const p = getPos(e);
            if(obs.dragging) {
                obs.x = Math.max(55, Math.min(canvas.width, p.x));
                obs.y = Math.max(50, Math.min(canvas.height - 50, p.y));
            } else {
                canvas.style.cursor = Math.hypot(p.x-obs.x, p.y-obs.y)<30 ? 'grab' : 'crosshair';
            }
        });
        
        window.addEventListener('mouseup', () => obs.dragging = false);
        
        // Touch support
        canvas.addEventListener('touchstart', e => {
             const p = getPos(e.touches[0]);
             if(Math.hypot(p.x - obs.x, p.y - obs.y) < 40) {
                 obs.dragging = true;
                 e.preventDefault();
             }
        }, {passive: false});
        
        canvas.addEventListener('touchmove', e => {
            if(obs.dragging) {
                const p = getPos(e.touches[0]);
                obs.x = Math.max(55, Math.min(canvas.width, p.x));
                obs.y = Math.max(50, Math.min(canvas.height - 50, p.y));
                e.preventDefault();
            }
        }, {passive: false});
        
        canvas.addEventListener('touchend', () => obs.dragging = false);

        document.getElementById('massSlider').addEventListener('input', (e) => {
            M = parseInt(e.target.value);
        });

        resize();
        initRays();
        draw();
    })();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Od Czarnej Dziury do Minkowskiego</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #050505;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 { margin: 15px 0 5px 0; font-size: 1.4rem; letter-spacing: 1px; text-transform: uppercase; color: #fff; }
        p { color: #888; font-size: 0.9rem; margin-bottom: 20px; text-align: center;}

        .container {
            position: relative;
            width: 95vw;
            height: 75vh;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
            background: #000;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(5px);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 300px;
            pointer-events: none;
        }
        
        .ui-element { pointer-events: auto; }
        .slider-group { margin-bottom: 20px; }
        label { display: block; font-size: 0.85rem; color: #aaa; margin-bottom: 8px; }
        input[type=range] { width: 100%; accent-color: #ffaa00; cursor: pointer; }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: #ccc;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

        .status-panel {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-family: monospace;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .zone-label {
            position: absolute;
            bottom: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>

    <h1>Od Czarnej Dziury do Minkowskiego</h1>
    <p>Przesuń obserwatora w prawo, aby zobaczyć jak czasoprzestrzeń się "prostuje" (zanik grawitacji).</p>

    <div class="container" id="canvasContainer">
        <canvas id="grCanvas"></canvas>
        
        <!-- Background Text Labels -->
        <div class="zone-label" style="left: 20px;">GRAWITACJA (Silna)</div>
        <div class="zone-label" style="right: 20px;">MINKOWSKI (Płaska)</div>

        <div class="ui-overlay">
            <div class="slider-group ui-element">
                <label>Masa Czarnej Dziury (M)</label>
                <!-- Domyślnie mniejsza masa, żeby zmieścić więcej "przestrzeni" -->
                <input type="range" id="massSlider" min="10" max="60" value="25">
            </div>

            <div class="legend-item"><span class="dot" style="background:rgba(68, 136, 255, 0.8)"></span> Stożek Świetlny</div>
            <div class="legend-item"><span class="dot" style="background:#ffaa00"></span> Promienie (Animacja)</div>
            <div class="legend-item"><span class="dot" style="background:#ff69b4; border:1px solid #666;"></span> Geodezyjne (Różowe)</div>
            <div class="legend-item"><span class="dot" style="background:#fff; border:1px solid #444;"></span> Obserwator</div>
            
            <div class="status-panel">
                Promień r: <span id="rVal" style="color:#fff">0.00</span> M<br>
                Prędkość rzeki: <span id="betaVal" style="color:#ffaa00">0.00</span> c<br>
                <small id="zoneText" style="color:#888">...</small>
            </div>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('grCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');

        // Physics Constants
        let M = 25; 
        let horizonR = 2 * M;
        
        // Observer Position
        let obs = { x: 600, y: 350, dragging: false };
        
        // Rays for background visualization
        let rays = [];
        const NUM_RAYS = 25; 

        // --- SETUP ---
        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            initRays();
        }
        window.addEventListener('resize', resize);

        // --- PHYSICS: GULLSTRAND-PAINLEVE ---
        function getMetricData(r) {
            if (r < 0.1) r = 0.1; 
            const beta = Math.sqrt((2 * M) / r); 
            // Local light cones slope (Time is Y axis, Radius is X axis)
            const slopeOut = 1 - beta;  // Right edge
            const slopeIn = -1 - beta;  // Left edge
            return { beta, slopeOut, slopeIn };
        }

        function initRays() {
            rays = [];
            for(let i=0; i<NUM_RAYS; i++) {
                rays.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    type: i % 2 === 0 ? 'out' : 'in', 
                    offset: Math.random() * 100
                });
            }
        }

        // --- DRAWING THE STATIC GRID ---
        function drawStaticGrid(w, h, singX) {
            const horizonX = singX + 2 * M;
            
            // RÓŻOWA SIATKA
            ctx.strokeStyle = 'rgba(255, 105, 180, 0.25)'; // Pinkish, faint
            ctx.lineWidth = 1.2;

            const stepSize = 4; // Integration step size (pixels)

            // 1. OUTGOING RAYS (Uciekające, Slope = 1 - beta)
            // ZAGĘSZCZENIE PRZY HORYZONCIE
            // Generujemy punkty startowe (na dole ekranu, y=h) nieliniowo.
            // Dużo punktów blisko horyzontu, rzadziej dalej.
            
            let startPoints = [];
            // Bardzo gęsto tuż za horyzontem (np. od 0 do 200px za horyzontem)
            for(let d = 0; d < 200; d += 8) startPoints.push(horizonX + d);
            // Średnio gęsto dalej
            for(let d = 200; d < w; d += 40) startPoints.push(horizonX + d);

            // Dodatkowe linie startujące z "lewej" strony (jeśli chcemy wypełnić górę), 
            // ale skoro ucinamy na horyzoncie, to wystarczy startować z dołu, byle gęsto.

            startPoints.forEach(startX => {
                if (startX < horizonX) return; // Nie rysujemy wewnątrz

                ctx.beginPath();
                let x = startX;
                let y = h; // Start at bottom
                ctx.moveTo(x, y);

                while (y > 0) {
                    let r = x - singX;
                    if (r < 2 * M) break; // STOP AT HORIZON (Nie przedłużaj w czarną dziurę)
                    
                    let m = getMetricData(r);
                    
                    // Move UP in time (y decreases)
                    y -= stepSize;
                    x += m.slopeOut * stepSize; 

                    ctx.lineTo(x, y);
                    
                    if (x < horizonX) break; // Extra safety clip
                }
                ctx.stroke();
            });

            // 2. INGOING RAYS (Wpadające, Slope = -1 - beta)
            // Te wpadają szybko, więc nie trzeba ich tak zagęszczać, ale dla estetyki rysujemy
            ctx.strokeStyle = 'rgba(255, 105, 180, 0.15)'; // Nieco słabsze
            
            for (let startX = horizonX; startX < w + h; startX += 50) {
                ctx.beginPath();
                let x = startX;
                let y = h; // Start mostly bottom/right
                
                // Dla wpadających startujemy też z prawej krawędzi, bo idą w lewo
                // Ale uprośćmy: startujemy z dołu dla spójności
                if (startX > w) { 
                    // Start from right edge? x = w, y varies?
                    // Let's keep loop simple from bottom
                }
                
                ctx.moveTo(x, y);

                while (y > 0) {
                    let r = x - singX;
                    
                    // STOP AT HORIZON (Zgodnie z życzeniem "nie przedłużaj")
                    if (r < 2 * M) break; 

                    let m = getMetricData(r);
                    
                    y -= stepSize;
                    x += m.slopeIn * stepSize; // Always negative

                    ctx.lineTo(x, y);
                    if (x < horizonX) break;
                }
                ctx.stroke();
            }
        }

        // --- MAIN DRAW LOOP ---
        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const singX = 50; 

            // 1. CLEAR & BACKGROUND
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Update Horizon
            horizonR = 2 * M;
            const horizonX = singX + horizonR;

            // 2. DRAW ZONES (Zamiast rysować wnętrze, zostawiamy je ciemne/wyróżnione)
            // Wnętrze czarnej dziury (Singularity to Horizon)
            const holeGrad = ctx.createLinearGradient(0, 0, horizonX, 0);
            holeGrad.addColorStop(0, '#000');
            holeGrad.addColorStop(1, '#1a0505'); // Lekko czerwonawy mrok
            ctx.fillStyle = holeGrad;
            ctx.fillRect(0, 0, horizonX, h);
            
            // Horizon Line
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.moveTo(horizonX, 0); ctx.lineTo(horizonX, h); ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#666'; ctx.font = '12px monospace';
            ctx.fillText("HORYZONT (r=2M)", horizonX + 5, 20);

            // 3. DRAW STATIC GRID (BACKGROUND) - PINK
            drawStaticGrid(w, h, singX);

            // 4. DRAW ANIMATED RAYS (FOREGROUND)
            ctx.strokeStyle = 'rgba(255, 170, 0, 0.6)'; // Brighter Yellow
            ctx.lineWidth = 2;

            rays.forEach(ray => {
                ctx.beginPath();
                let tx = ray.x;
                let ty = ray.y;
                
                // Animate
                ray.y -= 1.5; // Flow UP in time
                let r = ray.x - singX;
                let m = getMetricData(r);
                let dx = (ray.type === 'out' ? m.slopeOut : m.slopeIn) * 1.5;
                ray.x += dx;

                // Loop reset
                // Jeśli wpadnie do dziury (x < horizonX) też resetujemy, żeby nie rysować w środku?
                // Niech wpadają, to wygląda dobrze jako "znikające" w otchłani.
                // Ale tło statyczne ucięliśmy.
                
                if (ray.y < 0 || ray.x < singX + 2 || ray.x > w) {
                    ray.y = h;
                    // Respawn outside horizon mostly
                    ray.x = horizonX + Math.random() * (w - horizonX);
                }

                // Draw trail
                ctx.moveTo(ray.x, ray.y);
                let trailX = ray.x;
                let trailY = ray.y;
                
                // Draw tail backward
                for(let k=0; k<12; k++) {
                    let tr = trailX - singX;
                    if(tr < 1) break;
                    let tm = getMetricData(tr);
                    let slope = (ray.type === 'out' ? tm.slopeOut : tm.slopeIn);
                    
                    trailX -= slope * 6; 
                    trailY += 6; 
                    ctx.lineTo(trailX, trailY);
                }
                ctx.stroke();
                
                // Draw head dot
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath(); ctx.arc(ray.x, ray.y, 1.5, 0, Math.PI*2); ctx.fill();
            });

            // 5. OBSERVER & CONE
            const obsR = obs.x - singX;
            const obsM = getMetricData(obsR);
            
            // UI Data
            const rInM = obsR / M;
            document.getElementById('rVal').innerText = rInM.toFixed(1);
            document.getElementById('betaVal').innerText = obsM.beta.toFixed(3);
            const zoneText = document.getElementById('zoneText');
            if (obsR < horizonR) {
                zoneText.innerText = "WEWNĄTRZ CZARNEJ DZIURY\nBrak powrotu."; zoneText.style.color = "#ff4444";
            } else if (rInM > 15) {
                zoneText.innerText = "STREFA MINKOWSKIEGO\nCzasoprzestrzeń prawie płaska."; zoneText.style.color = "#4488ff";
            } else {
                zoneText.innerText = "ZAKRZYWIONA CZASOPRZESTRZEŃ\nZauważalne przechylenie stożków."; zoneText.style.color = "#e0e0e0";
            }

            // Draw Light Cone
            const coneH = 100; 
            const dxRight = obsM.slopeOut * coneH;
            const pRightX = obs.x + dxRight;
            const pRightY = obs.y - coneH;
            const dxLeft = obsM.slopeIn * coneH;
            const pLeftX = obs.x + dxLeft;
            const pLeftY = obs.y - coneH;

            const coneGrad = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y - coneH);
            coneGrad.addColorStop(0, 'rgba(68, 136, 255, 0.7)');
            coneGrad.addColorStop(1, 'rgba(68, 136, 255, 0.1)');

            ctx.fillStyle = coneGrad;
            ctx.beginPath(); ctx.moveTo(obs.x, obs.y); 
            ctx.lineTo(pRightX, pRightY); ctx.lineTo(pLeftX, pLeftY); 
            ctx.closePath(); ctx.fill();
            
            ctx.strokeStyle = '#4488ff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(obs.x, obs.y); ctx.lineTo(pRightX, pRightY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(obs.x, obs.y); ctx.lineTo(pLeftX, pLeftY); ctx.stroke();
            
            // Local Time Axis
            const tiltX = obs.x - (obsM.beta * coneH);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.setLineDash([2,4]);
            ctx.beginPath(); ctx.moveTo(obs.x, obs.y); ctx.lineTo(tiltX, obs.y - coneH); ctx.stroke(); ctx.setLineDash([]);

            // Observer Dot
            ctx.beginPath(); ctx.arc(obs.x, obs.y, 6, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill();
            if(obs.dragging) {
                ctx.beginPath(); ctx.arc(obs.x, obs.y, 12, 0, Math.PI*2);
                ctx.strokeStyle = '#fff'; ctx.stroke();
            }

            requestAnimationFrame(draw);
        }

        // --- INTERACTION ---
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            return { x: e.clientX - r.left, y: e.clientY - r.top };
        }
        canvas.addEventListener('mousedown', e => {
            const p = getPos(e);
            if(Math.hypot(p.x - obs.x, p.y - obs.y) < 30) obs.dragging = true;
        });
        window.addEventListener('mousemove', e => {
            const p = getPos(e);
            if(obs.dragging) {
                obs.x = Math.max(55, Math.min(canvas.width, p.x));
                obs.y = Math.max(50, Math.min(canvas.height - 50, p.y));
            } else {
                canvas.style.cursor = Math.hypot(p.x-obs.x, p.y-obs.y)<30 ? 'grab' : 'crosshair';
            }
        });
        window.addEventListener('mouseup', () => obs.dragging = false);
        canvas.addEventListener('touchstart', e => {
             const p = getPos(e.touches[0]);
             if(Math.hypot(p.x - obs.x, p.y - obs.y) < 40) { obs.dragging = true; e.preventDefault(); }
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            if(obs.dragging) {
                const p = getPos(e.touches[0]);
                obs.x = Math.max(55, Math.min(canvas.width, p.x));
                obs.y = Math.max(50, Math.min(canvas.height - 50, p.y));
                e.preventDefault();
            }
        }, {passive: false});
        canvas.addEventListener('touchend', () => obs.dragging = false);
        document.getElementById('massSlider').addEventListener('input', (e) => { M = parseInt(e.target.value); });

        resize();
        initRays();
        draw();
    })();
    </script>
</body>
</html>